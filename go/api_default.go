/*
 * SyskenGacha-backend
 *
 * SyskenGachaのバックエンド。
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"database/sql"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	_ "github.com/mattn/go-sqlite3"
	"golang.org/x/crypto/bcrypt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
)

func OpenDB() *sql.DB {
	godotenv.Load()
	println(os.Getenv("DB_PATH"))
	println("db open")
	db, err := sql.Open("sqlite3", os.Getenv("DB_PATH"))
	if err != nil {
		log.Fatal(err)
	}
	println("db open end")
	return db
	//sqlStmt := `
	//create table foo (id integer not null primary key, name text);
	//delete from foo;
	//`
	//_, err = db.Exec(sqlStmt)
	//if err != nil {
	//	log.Printf("%q: %s\n", err, sqlStmt)
	//	return
	//}
}

// AdminItemPost -
func AdminItemPost(c *gin.Context) {
	//c.GetPostFormMap()
	db := OpenDB()
	var boolMap map[int64]bool
	var name, pictId, rareString string

	name, boolMap[0] = c.GetPostForm("name")
	pictId, boolMap[1] = c.GetPostForm("pict_id")
	rareString, boolMap[2] = c.GetPostForm("rare")
	rare, err := strconv.Atoi(rareString)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{})
		log.Fatal(err)
	}

	InsertResult, err := db.Exec("INSERT INTO items (name, pict_id, rare) VALUES (?, ?, ?)", name, pictId, rare)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{})
		log.Fatal(err)
	}
	LastInsertId, err := InsertResult.LastInsertId()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{})
		log.Fatal(err)
	}
	RowsAffected, err := InsertResult.RowsAffected()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{})
		log.Fatal(err)
	}
	c.JSON(http.StatusOK, gin.H{"LastID": LastInsertId, "RowsAffected": RowsAffected})
}

// AdminItemPut -
func AdminItemPut(c *gin.Context) {
	db := OpenDB()
	var keys []string
	id := c.Request.FormValue("id")
	if id == "" {
		log.Fatal("id is empty")
	}

	name := c.Request.FormValue("name")
	if name == "" {
		keys = append(keys, "name")
	}
	pictId := c.Request.FormValue("pict_id")
	if pictId == "" {
		keys = append(keys, "pict_id")
	}
	rare := c.Request.FormValue("rare")
	if rare == "" {
		keys = append(keys, "rare")
	}

	UpdateResult, err := db.Exec("UPDATE items SET name = ?, pict_id = ?, rare = ? WHERE id = ?", name, pictId, rare, id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{})
		log.Fatal(err)
	}
	LastInsertId, err := UpdateResult.LastInsertId()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{})
		log.Fatal(err)
	}

	RowsAffected, err := UpdateResult.RowsAffected()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{})
		log.Fatal(err)
	}

	c.JSON(http.StatusOK, gin.H{"LastID": LastInsertId, "RowsAffected": RowsAffected})
}

// AdminUploadPost -
func AdminUploadPost(c *gin.Context) {
	err := c.Request.ParseMultipartForm(32 << 20)
	if err != nil {
		log.Printf(err.Error())
		c.String(http.StatusBadRequest, "Illegal Form")
	}
	file, handler, err := c.Request.FormFile("file")
	if err != nil {
		log.Printf(err.Error())
		c.JSON(http.StatusInternalServerError, gin.H{})
	}
	defer file.Close()
	log.Printf("Uploaded File: %+v\n", handler.Filename)
	log.Printf("File Size: %+v\n", handler.Size)
	log.Printf("MIME Header: %+v\n", handler.Header)
	Dest, err := os.Create(handler.Filename)
	if err != nil {
		log.Printf(err.Error())
		c.JSON(http.StatusInternalServerError, gin.H{})
	}
	defer func(Dest *os.File) {
		err := Dest.Close()
		if err != nil {
			log.Fatal(err.Error())
		}
	}(Dest)
	// fw :=bufio.NewWriter(fileCur)
	_, err = io.Copy(Dest, file)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{})
		log.Fatal(err.Error())
	}
	c.JSON(http.StatusOK, gin.H{})
	// fileCur.Write(file.Read())
}

// AuthUserIdPost - ユーザー認証

// GetTokenHandler get token
func AuthUserIdPost(c *gin.Context) {
	err := c.Request.ParseForm()
	if err != nil {
		log.Fatal(err)
	}
	tokenString, err := GetToken(c.Request.Form["user_id"][0])
	if err != nil {
		log.Fatal(err)
	}
	c.String(http.StatusOK, tokenString)
}

// BcryptGet - パスワードをハッシュ化します
func BcryptGet(c *gin.Context) {
	err := c.Request.ParseForm()
	if err != nil {
		log.Fatal(err)
	}
	password := c.Request.Form["password"][0]
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Fatal(err)
	}
	c.String(http.StatusOK, string(hash))
	//c.JSON(http.StatusOK, gin.H{})
}

// GachaGet - ガチャリスト
func GachaGet(c *gin.Context) {
	db := OpenDB()
	rows, err := db.Query("SELECT id,description,rare,coalesce(image,''),source FROM items")
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	var gachaList []GachaItem
	for rows.Next() {
		var gacha GachaItem
		err := rows.Scan(&gacha.Id, &gacha.Name, &gacha.Rare, &gacha.PictId, &gacha.Source)
		if err != nil {
			log.Fatal(err)
		}
		gachaList = append(gachaList, gacha)
	}
	c.JSON(http.StatusOK, gachaList)
}

// GachaItemIdGet - ガチャアイテム
func GachaItemIdGet(c *gin.Context) {
	db := OpenDB()
	type ReqId struct {
		ItemId int `uri:"id" binding:"required"`
	}
	var req ReqId
	if err := c.ShouldBindUri(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	rows, err := db.Query("SELECT id,description,rare,coalesce(image,''),source FROM items WHERE id = ? limit 1", req.ItemId)
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	var gacha GachaItem
	if rows.Next() {
		err := rows.Scan(&gacha.Id, &gacha.Name, &gacha.Rare, &gacha.PictId, &gacha.Source)
		if err != nil {
			log.Fatal(err)
		}
	} else {
		c.JSON(http.StatusNotFound, gin.H{})
		return
	}
	c.JSON(http.StatusOK, gacha)
}

// RandomGet - ランダムなガチャアイテム
func RandomGet(c *gin.Context) {
	db := OpenDB()
	rows, err := db.Query(
		"SELECT id,description,rare,coalesce(image,''),source FROM items ORDER BY random() LIMIT 1")
	if err != nil {
		println("opendb fatal error")
		log.Fatal(err)
	}
	var gacha GachaItem
	if rows.Next() {
		err = rows.Scan(&gacha.Id, &gacha.Name, &gacha.Rare, &gacha.PictId, &gacha.Source)
		if err != nil {
			log.Fatal(err)
		}
	}
	c.JSON(http.StatusOK, gacha)
}

type IdBindRequest struct {
	id int `uri:"id" binding:"required"`
}

// StaticPictIdGet - 画像
func StaticPictIdGet(c *gin.Context) {
	println("staticidget start")
	type Req struct {
		ItemId int `uri:"id" binding:"required"`
	}
	var req Req
	if err := c.ShouldBindUri(&req); err != nil {
		c.Error(err)
		log.Fatal(err)
		return
	}
	//c.JSON(http.StatusOK, gin.H{"request.id": req.ItemId})
	println("id:", strconv.Itoa(req.ItemId))
	db := OpenDB()
	rows, err :=
		db.Query("SELECT id,coalesce(image,''),source FROM items WHERE id = ? LIMIT 1", req.ItemId)
	if err != nil {
		log.Fatal(err.Error())
	}
	defer rows.Close()
	var item struct {
		id     int
		image  string
		source string
	}
	if rows.Next() {
		err := rows.Scan(&item.id, &item.image, &item.source)
		if err != nil {
			log.Println(err.Error())
			return
		}
	} else {
		c.String(http.StatusNotFound, "")
		return
	}
	println("id:%d", item.id)
	w := c.Writer
	var file io.ReadCloser
	switch item.source {
	case "local":
		file, err = getLocalImage(item.image)
		if err != nil {
			log.Println(err.Error())
			c.String(http.StatusInternalServerError, "")
			return
		}
		if _, err := io.Copy(w, file); err != nil {
			log.Fatal()
		}
		return
	case "url":
		file, err := getRemoteImage(item.image)
		defer file.Close()
		if err != nil {
			log.Println("something error happen")
			c.String(http.StatusNotFound, "ErrorOccuredWhileFetching")
			log.Print(err)
			return
		}
		if _, err := io.Copy(w, file); err != nil {
			log.Fatalln(err)
		}
		return
	default:
		c.String(http.StatusInternalServerError, "UnexpectedSource")
		return
	}

}

// formValidate - フォームバリデーション
func formValidate(c *gin.Context, keys []string) bool {
	if err := c.Request.ParseForm(); err != nil {
		log.Println("formValidate:ParseForm: ", err)
	}

	for key, value := range c.Request.Form {
		log.Printf("key: %s, value: %s", key, value)
	}
	for _, v := range keys {
		if c.Request.Form[v] == nil {
			return false
		}
	}
	return true
}
func isKeysExist(c *gin.Context, keys []string) map[string]bool {
	err := c.Request.ParseForm()
	if err != nil {
		log.Fatal(err)
	}
	existencesMap := make(map[string]bool)
	for _, v := range keys {
		if c.Request.Form[v] != nil && c.Request.Form[v][0] != "" {
			existencesMap[v] = true
		} else {
			existencesMap[v] = false
		}
	}
	return existencesMap
}
